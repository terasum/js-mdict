"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MDX = void 0;
const mdict_js_1 = require("./mdict.js");
const utils_js_1 = __importDefault(require("./utils.js"));
class MDX extends mdict_js_1.Mdict {
    /**
     * lookup the word
     * @tests ok
     * @param word search word
     * @returns word definition
     */
    lookup(word) {
        const keyWordItem = this.lookupKeyBlockByWord(word);
        if (!keyWordItem) {
            return {
                keyText: word,
                definition: null
            };
        }
        const def = this.lookupRecordByKeyBlock(keyWordItem);
        if (!def) {
            return {
                keyText: word,
                definition: null
            };
        }
        return {
            keyText: word,
            definition: this.meta.decoder.decode(def)
        };
    }
    ;
    fetch(keywordItem) {
        const def = this.lookupRecordByKeyBlock(keywordItem);
        if (!def) {
            return {
                keyText: keywordItem.keyText,
                definition: null
            };
        }
        return {
            keyText: keywordItem.keyText,
            definition: this.meta.decoder.decode(def)
        };
    }
    /**
     * search the prefix like the phrase in the dictionary
     * @tests ok
     * @param prefix prefix search phrase
     * @returns the prefix related list
     */
    prefix(prefix) {
        const keywordList = this.associate(prefix);
        return keywordList.filter(item => {
            return item.keyText.startsWith(prefix);
        });
    }
    /**
     * search matched list of associate words
     * @tests ok
     * @param phrase associate search likely workds
     * @returns matched list
     */
    associate(phrase) {
        const keyBlockItem = this.lookupKeyBlockByWord(phrase);
        if (!keyBlockItem) {
            return [];
        }
        return this.keywordList.filter((keyword) => {
            return keyword.keyBlockIdx == keyBlockItem.keyBlockIdx;
        });
    }
    fetch_definition(keywordItem) {
        const def = this.lookupRecordByKeyBlock(keywordItem);
        if (!def) {
            return {
                keyText: keywordItem.keyText,
                definition: null
            };
        }
        return {
            keyText: keywordItem.keyText,
            definition: this.meta.decoder.decode(def)
        };
    }
    /**
     * fuzzy search words list
     * @tests ok
     * @param word search word
     * @param fuzzy_size the fuzzy workd size
     * @param ed_gap edit distance
     * @returns fuzzy word list
     */
    fuzzy_search(word, fuzzy_size, ed_gap) {
        const fuzzy_words = [];
        let count = 0;
        const keywordList = this.associate(word);
        keywordList.forEach(item => {
            const key = this.strip(item.keyText);
            const ed = utils_js_1.default.levenshteinDistance(key, this.strip(word));
            if (ed <= ed_gap) {
                count++;
                if (count > fuzzy_size) {
                    return;
                }
                fuzzy_words.push(Object.assign(Object.assign({}, item), { key: item.keyText, idx: item.recordStartOffset, ed: ed }));
            }
        });
        return fuzzy_words;
    }
}
exports.MDX = MDX;
//# sourceMappingURL=mdx.js.map